#!/usr/bin/env perl6
use OpenAPI::Model;
use JSON::Fast;
use Template::Mustache;
use Cro::WebApp::Template::Repository;

my $apij = from-json $*PROGRAM.add('../api.json').resolve.slurp;
my $api = OpenAPI::Model.from-json($*PROGRAM.add('../api.json').resolve.slurp);

class RakuParam {
    has Str $.name;
    has Str $.type;
    has Str $.sigil = '$';
    has Bool $.required;
}

class RakuMethod {
    has Str $.name;
    has RakuParam @.params;
    has Str $.code;
    has Bool $.data-required;
}

class RakuClass {
    has RakuMethod @.methods;
    has Str @.bases;
    has Str $.name;
    has Str $.pod;
}
my $template-repo = get-template-repository;
$template-repo.add-location($*PROGRAM.add('../templates').resolve);
my %classes;

for $api.paths -> $paths {
    for flat $paths.kv -> Str $path-template , $path {
        for <get put post delete options head patch trace> -> $method {
            with $path."$method"() -> $operation {
                my $usbcategory = $apij<paths>{$path-template}{$method}<x-github><subcategory> // '';
                my $category = $apij<paths>{$path-template}{$method}<x-github><category>;
                my $data-required = False;
                if $method ne 'get' && have-requestBody($operation) {
                    my $c = $operation.request-body.content<application/json>;
                    $data-required = $c.schema<required>.elems.Bool;
                }
                my $class = $category.split("/")[0].split("-")>>.wordcase.join;
                my $method-name = $operation.operation-id.split("/")[*- 1];
                my @params = $operation.parameters;
                my @param-code = gen-prams(@params);
                my $request-path = fix-path($path-template);
                my $rmethod = RakuMethod.new(
                        :name($method-name), :params(@param-code),
                        :code("self.request(\"$request-path\",\"{ $method.uc }\",:%data)"),
                        :$data-required);
                my $pod = "=head2 { $operation.summary }\n=begin para\nSee L<{ $operation.operation-id }|{ $operation.external-docs.url // "https://docs.github.com/en/rest/reference/{ $operation.operation-id.split("/")[0] }" }> \n=end para\n";
                $pod ~= '=begin code' ~ "\n";
                my @parms-code = @param-code.map(-> $parma { (await $template-repo.resolve('param.crotmp')).render({ :param($parma) }); });
                $pod ~= "\t" ~ "$class." ~ $method-name ~ '( ' ~ @parms-code.join(', ') ~ ' )' ~ "\n";
                $pod ~= '=end code' ~ "\n";

                if $usbcategory && $usbcategory ne $category {
                    %classes{$class}<subcategory>{$usbcategory}<submethods>.push: $rmethod;
                    %classes{$class}<subcategory>{$usbcategory}<pods>.push: $pod;
                } else {
                    %classes{$class}<pods>.push: $pod;
                    %classes{$class}<methods>.push: $rmethod;
                }

            }
        }
    }
}

for %classes.kv -> $class-name , %data {
    my $class-path = "..\\lib\\$class-name.rakumod";

    if %data<subcategory>.elems {
        for %data<subcategory>.kv -> $subname , %subdata {
            say $class-name ~ '::' ~ $subname.split("-")>>.wordcase.join;
            my $subclass-path = "..\\lib\\$class-name\\{ $subname.split("-")>>.wordcase.join }.rakumod";
            my $subclass = RakuClass.new(:name($class-name ~ '::' ~ $subname.split("-")>>.wordcase.join),
                    :methods(|%subdata<submethods>), :bases<WebService::GitHub::Role>);
            my $subcode = (await $template-repo.resolve('class.crotmp')).render({ :class($subclass) });
            my $pod;
            $pod ~= '=begin pod' ~ "\n";
            $pod ~= '=head1 ' ~ "$class-name" ~ "\n";
            $pod ~= %subdata<pods>[*].join("\n\n");
            $pod ~= '=end pod' ~ "\n";
            mkdir $*PROGRAM.add("..\\lib\\$class-name").Str unless $*PROGRAM.add("..\\lib\\$class-name").resolve.e;
            $*PROGRAM.add($subclass-path).resolve.spurt($subcode);
            $*PROGRAM.add("..\\lib\\$class-name\\{ $subname.split("-")>>.wordcase.join }.pod6").resolve.spurt($pod);
        }
    }
    if %data<methods> {
        say $class-name;
        my $pod;
        $pod ~= '=begin pod' ~ "\n";
        $pod ~= '=head1 ' ~ "$class-name" ~ "\n";
        $pod ~= %data<pods>[*].join("\n\n") if %data<pods>;
        $pod ~= '=end pod' ~ "\n";
        my $class = RakuClass.new(:name($class-name), :methods(|%data<methods>), :bases<WebService::GitHub::Role>);
        my $code = (await $template-repo.resolve('class.crotmp')).render({ :$class });
        $*PROGRAM.add($class-path).resolve.spurt($code);
        $*PROGRAM.add("..\\lib\\$class-name.pod6").resolve.spurt($pod);
    }
}



sub get-raku-type(Str $type) {
    given $type {
        when 'integer' {
            'Int(Str)', '$';
        }
        when 'string' {
            'Str', '$'
        }
        when 'boolean' {
            'Bool', '$'
        }
        when 'number' {
            'Num', '$'
        }
        when 'array' {
            'List', '@'
        }
        when 'object' {
            'Hash', '%'
        }
        default {
            'Any', '$'
        }
    }
}

sub fix-path(Str $path is copy) {
    $path.match(/['{'(\w+)'}']+/, :global).map(-> $match {
        $path .= subst($match.Str, '$' ~ $match[0].Str.trans('_' => '-'))
    });
    $path;
}

sub have-requestBody($operation) {
    $operation.request-body.content<application/json>.defined;
}


sub gen-prams(@params) {
    my @res;
    for @params.grep(*.in eq 'path') -> $param {
        my $name = $param.name.trans('_' => '-');
        my ($type,$sigil);
        if $param.schema<type>:exists {
            ($type, $sigil) = get-raku-type($param.schema<type>)
        } else {
            say "TODO: Generate valid";
            ($type, $sigil) = 'Any', '$';
        }
        @res.push: RakuParam.new(
                :$name,
                :$type,
                :required($param.required),
                :$sigil
                );
    }
    @res
}

